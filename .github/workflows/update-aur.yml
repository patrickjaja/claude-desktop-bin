name: Update AUR Package

on:
  schedule:
    - cron: '0 2 * * *'  # Run daily at 2 AM UTC
  workflow_dispatch:  # Allow manual trigger
    inputs:
      download_url:
        description: 'Manual download URL (optional - bypasses auto-detection if Cloudflare blocks)'
        required: false
        type: string
      force_rebuild:
        description: 'Force rebuild & release even if upstream version unchanged (bumps pkgrel for patch/feature updates)'
        required: false
        type: boolean
        default: false
  push:
    branches:
      - master
    paths:
      - '.github/workflows/update-aur.yml'
      - 'scripts/**'
      - 'patches/**'
      - 'PKGBUILD.template'

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Need write permission to create releases
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git changelog generation

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full wget

      - name: Download Claude Setup and capture URL
        id: download
        run: |
          # Check if manual download URL was provided via workflow_dispatch input
          if [ -n "${{ github.event.inputs.download_url }}" ]; then
            echo "Using manually provided download URL"
            DOWNLOAD_URL="${{ github.event.inputs.download_url }}"
            echo "Download URL: ${DOWNLOAD_URL}"

            # Download using the provided URL
            wget -q -O Claude-Setup-x64.exe \
              -U "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "${DOWNLOAD_URL}"
          else
            echo "Auto-detecting download URL from redirect"
            # Download the file and capture headers in verbose mode
            # wget follows redirects by default and logs the final URL
            wget --server-response -O Claude-Setup-x64.exe \
              -U "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
              "https://claude.ai/api/desktop/win32/x64/exe/latest/redirect" \
              2>&1 | tee wget_output.txt

            # Extract the Location header from the redirect response
            DOWNLOAD_URL=$(grep -i '^ *Location:' wget_output.txt | tail -1 | sed -E 's/^[[:space:]]*[Ll]ocation:[[:space:]]*//' | sed 's/ \[following\]$//' | tr -d '\r\n')

            if [ -z "$DOWNLOAD_URL" ]; then
              echo "Error: Failed to extract download URL from redirect"
              echo "wget output:"
              cat wget_output.txt
              exit 1
            fi

            echo "Resolved download URL: ${DOWNLOAD_URL}"
            rm -f wget_output.txt
          fi

          # Save URL to output for reference
          echo "url=${DOWNLOAD_URL}" >> $GITHUB_OUTPUT

      - name: Extract version
        id: version
        run: |
          VERSION=$(bash ./scripts/extract-version.sh Claude-Setup-x64.exe)
          echo "Version extracted: ${VERSION}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Check if version changed
        id: check
        run: |
          # Get the latest tag from GitHub releases
          LATEST_TAG=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/latest | grep '"tag_name":' | sed -E 's/.*"v?([^"]+)".*/\1/' || echo "0.0.0")
          # Strip pkgrel suffix (e.g., 1.1.2685-2 → 1.1.2685) for comparison
          LATEST_VERSION=$(echo "$LATEST_TAG" | sed -E 's/-[0-9]+$//')
          echo "Latest GitHub release tag: ${LATEST_TAG}"
          echo "Latest upstream version: ${LATEST_VERSION}"
          echo "Current version: ${{ steps.version.outputs.version }}"

          if [ "$LATEST_VERSION" != "${{ steps.version.outputs.version }}" ]; then
            echo "needs_update=true" >> $GITHUB_OUTPUT
            echo "Version changed from ${LATEST_VERSION} to ${{ steps.version.outputs.version }}"
          else
            echo "needs_update=false" >> $GITHUB_OUTPUT
            echo "Version unchanged"
          fi

      - name: Determine package release number
        id: pkgrel
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          FORCE="${{ github.event.inputs.force_rebuild }}"
          NEEDS_UPDATE="${{ steps.check.outputs.needs_update }}"

          if [ "$FORCE" == "true" ] && [ "$NEEDS_UPDATE" != "true" ]; then
            # Same upstream version, force rebuild — bump pkgrel
            RELEASE_COUNT=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100" \
              | jq "[.[] | select(.tag_name | test(\"^v${VERSION}(-[0-9]+)?$\"))] | length")
            PKGREL=$((RELEASE_COUNT + 1))
          else
            # New upstream version or normal scheduled build
            PKGREL=1
          fi

          if [ "$PKGREL" -gt 1 ]; then
            TAG="v${VERSION}-${PKGREL}"
            RELEASE_NAME="Claude Desktop ${VERSION} (patch release ${PKGREL})"
          else
            TAG="v${VERSION}"
            RELEASE_NAME="Claude Desktop ${VERSION}"
          fi

          echo "pkgrel=${PKGREL}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "release_name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
          echo "Package release: pkgrel=${PKGREL}, Tag: ${TAG}"

      - name: Generate changelog from git history
        id: git_changelog
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          # Find the latest release tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            echo "Generating changelog since ${LAST_TAG}"
            CHANGELOG=$(git log "${LAST_TAG}..HEAD" --format="%ad|%s" --date=short --no-merges --reverse | \
              awk -F'|' '
                $1 != prev_date {
                  if (prev_date) print "";
                  print "### " $1;
                  prev_date = $1
                }
                { print "- " $2 }
              ')
          else
            echo "No previous tag found, using recent commits"
            CHANGELOG=$(git log -30 --format="%ad|%s" --date=short --no-merges --reverse | \
              awk -F'|' '
                $1 != prev_date {
                  if (prev_date) print "";
                  print "### " $1;
                  prev_date = $1
                }
                { print "- " $2 }
              ')
          fi

          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="No changes since last release."
          fi

          echo "content<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build Patched Tarball
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        id: build
        run: |
          echo "=== Building pre-patched tarball in Arch Linux container ==="

          # Prepare build directory
          mkdir -p /tmp/build-input /tmp/build-output
          cp Claude-Setup-x64.exe /tmp/build-input/
          cp -r scripts patches /tmp/build-input/

          # Run build in Arch container
          docker run --rm \
            -v /tmp/build-input:/input:ro \
            -v /tmp/build-output:/output \
            archlinux:base-devel \
            bash -c "
              set -eo pipefail

              echo '=== Installing build dependencies ==='
              pacman -Syu --noconfirm
              pacman -S --noconfirm p7zip python nodejs npm git icoutils xorg-server-xvfb electron

              echo '=== Installing asar from AUR ==='
              useradd -m builder
              echo 'builder ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers
              cd /tmp
              git clone https://aur.archlinux.org/yay-bin.git
              chown -R builder:builder yay-bin
              cd yay-bin
              su builder -c 'makepkg -si --noconfirm'
              su builder -c 'yay -S --noconfirm asar'

              echo '=== Running build script ==='
              bash /input/scripts/build-patched-tarball.sh /input/Claude-Setup-x64.exe /output

              echo '=== Build completed ==='
            " 2>&1 | tee build-output.log

          BUILD_EXIT=${PIPESTATUS[0]}

          if [ $BUILD_EXIT -ne 0 ]; then
            echo ""
            echo "::error::Build FAILED!"
            echo ""
            echo "=== PATCH FAILURE DETAILS ==="
            grep -E "(ERROR|FAIL|\[FAIL\])" build-output.log || true
            echo ""
            echo "The upstream Claude Desktop may have changed."
            echo "Please update the patch patterns to match the new file structure."
            exit 1
          fi

          # Read build info
          source /tmp/build-output/build-info.txt
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tarball_sha256=${SHA256}" >> $GITHUB_OUTPUT

          # Copy tarball to workspace
          cp /tmp/build-output/claude-desktop-*-linux.tar.gz .

          echo "Build passed - tarball ready for upload"
          echo "  Version: ${VERSION}"
          echo "  SHA256:  ${SHA256}"

      - name: Upload Build Log
        if: always() && (steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch')
        uses: actions/upload-artifact@v4
        with:
          name: build-log-${{ steps.version.outputs.version }}
          path: build-output.log
          retention-days: 30
          if-no-files-found: ignore

      - name: Generate PKGBUILD
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        env:
          AUR_USERNAME: ${{ secrets.AUR_USERNAME }}
          AUR_EMAIL: ${{ secrets.AUR_EMAIL }}
        run: |
          TAG="${{ steps.pkgrel.outputs.tag }}"
          PREBUILT_URL="https://github.com/${{ github.repository }}/releases/download/${TAG}/claude-desktop-${{ steps.version.outputs.version }}-linux.tar.gz"
          bash ./scripts/generate-pkgbuild.sh "${{ steps.version.outputs.version }}" "${{ steps.build.outputs.tarball_sha256 }}" "$PREBUILT_URL" "${{ steps.pkgrel.outputs.pkgrel }}" > PKGBUILD
          cat PKGBUILD

      - name: Extract Changelog for Release
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        id: changelog
        run: |
          # Extract the latest changelog section (up to the next date header)
          CHANGELOG=$(awk '/^## [0-9]{4}-[0-9]{2}-[0-9]{2}/ { if (found) exit; found=1; next } found' CHANGELOG.md)

          # If no changelog entry for today, use the first section
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG=$(awk 'BEGIN{found=0} /^## [0-9]{4}-[0-9]{2}-[0-9]{2}/ { if (found==1) exit; found=1; next } found==1' CHANGELOG.md)
          fi

          # Escape for GitHub Actions output
          echo "content<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate .SRCINFO
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          # Generate .SRCINFO from PKGBUILD
          cat << 'EOF' > generate-srcinfo.sh
          #!/bin/bash
          source PKGBUILD

          echo "pkgbase = ${pkgname}"
          echo -e "\tpkgdesc = ${pkgdesc}"
          echo -e "\tpkgver = ${pkgver}"
          echo -e "\tpkgrel = ${pkgrel}"
          echo -e "\turl = ${url}"
          echo -e "\tarch = ${arch[0]}"
          echo -e "\tlicense = ${license[0]}"

          for dep in "${makedepends[@]}"; do
            echo -e "\tmakedepends = ${dep}"
          done

          for dep in "${depends[@]}"; do
            echo -e "\tdepends = ${dep}"
          done

          for src in "${source_x86_64[@]}"; do
            echo -e "\tsource_x86_64 = ${src}"
          done

          for sum in "${sha256sums_x86_64[@]}"; do
            echo -e "\tsha256sums_x86_64 = ${sum}"
          done

          echo ""
          echo "pkgname = ${pkgname}"
          EOF

          bash generate-srcinfo.sh > .SRCINFO
          rm generate-srcinfo.sh
          cat .SRCINFO

      - name: Build AppImage
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        id: appimage
        run: |
          echo "=== Building AppImage ==="
          VERSION="${{ steps.version.outputs.version }}"
          TARBALL="claude-desktop-${VERSION}-linux.tar.gz"

          # Install dependencies
          sudo apt-get install -y wget unzip file

          # Get latest Electron version
          ELECTRON_VERSION=$(curl -s https://api.github.com/repos/electron/electron/releases/latest | grep '"tag_name":' | sed -E 's/.*"v([^"]+)".*/\1/')
          echo "Using Electron version: ${ELECTRON_VERSION}"
          echo "electron_version=${ELECTRON_VERSION}" >> $GITHUB_OUTPUT

          # Run AppImage build script
          export ELECTRON_VERSION
          bash packaging/appimage/build-appimage.sh "$TARBALL" ./dist

          # Get output info
          APPIMAGE_FILE=$(ls dist/*.AppImage)
          APPIMAGE_SHA256=$(sha256sum "$APPIMAGE_FILE" | cut -d' ' -f1)
          echo "appimage_sha256=${APPIMAGE_SHA256}" >> $GITHUB_OUTPUT

          echo "AppImage built: $APPIMAGE_FILE"
          echo "SHA256: $APPIMAGE_SHA256"

      - name: Build Debian Package
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        id: deb
        run: |
          echo "=== Building Debian Package ==="
          VERSION="${{ steps.version.outputs.version }}"
          TARBALL="claude-desktop-${VERSION}-linux.tar.gz"

          # Install dependencies
          sudo apt-get install -y dpkg fakeroot

          # Run Debian build script
          bash packaging/debian/build-deb.sh "$TARBALL" ./dist

          # Get output info
          DEB_FILE=$(ls dist/*.deb)
          DEB_SHA256=$(sha256sum "$DEB_FILE" | cut -d' ' -f1)
          echo "deb_sha256=${DEB_SHA256}" >> $GITHUB_OUTPUT

          echo "Debian package built: $DEB_FILE"
          echo "SHA256: $DEB_SHA256"

      - name: Create GitHub Release
        if: steps.check.outputs.needs_update == 'true' || github.event.inputs.force_rebuild == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.pkgrel.outputs.tag }}
          name: ${{ steps.pkgrel.outputs.release_name }}
          files: |
            claude-desktop-${{ steps.version.outputs.version }}-linux.tar.gz
            dist/Claude_Desktop-${{ steps.version.outputs.version }}-x86_64.AppImage
            dist/claude-desktop_${{ steps.version.outputs.version }}_amd64.deb
          body: |
            ## ${{ steps.pkgrel.outputs.release_name }}

            This release provides Claude Desktop version ${{ steps.version.outputs.version }} pre-patched for Linux.

            ### Installation Options

            **Arch Linux (AUR)**
            ```bash
            yay -S claude-desktop-bin
            ```

            **Debian/Ubuntu (.deb)**
            ```bash
            # Download the .deb file, then:
            sudo apt install ./claude-desktop_${{ steps.version.outputs.version }}_amd64.deb
            # Note: Requires 'electron' package from your distro or a PPA
            ```

            **AppImage (Any Distro)**
            ```bash
            chmod +x Claude_Desktop-${{ steps.version.outputs.version }}-x86_64.AppImage
            ./Claude_Desktop-${{ steps.version.outputs.version }}-x86_64.AppImage
            ```

            ### Checksums
            | File | SHA256 |
            |------|--------|
            | Tarball | `${{ steps.build.outputs.tarball_sha256 }}` |
            | AppImage | `${{ steps.appimage.outputs.appimage_sha256 }}` |
            | Debian | `${{ steps.deb.outputs.deb_sha256 }}` |

            ### Changes since last release
            ${{ steps.git_changelog.outputs.content }}

            ### Links
            - [AUR Package](https://aur.archlinux.org/packages/claude-desktop-bin)
            - [Full Changelog](https://github.com/${{ github.repository }}/blob/master/CHANGELOG.md)
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify release tarball download
        if: steps.check.outputs.needs_update == 'true' || github.event.inputs.force_rebuild == 'true'
        run: |
          TAG="${{ steps.pkgrel.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"
          EXPECTED_SHA="${{ steps.build.outputs.tarball_sha256 }}"
          URL="https://github.com/${{ github.repository }}/releases/download/${TAG}/claude-desktop-${VERSION}-linux.tar.gz"

          echo "Verifying release tarball at: ${URL}"
          for i in 1 2 3 4 5; do
            if wget -q -O /tmp/verify-tarball.tar.gz "${URL}" 2>/dev/null; then
              break
            fi
            echo "Attempt $i failed, waiting 10s..."
            sleep 10
          done

          if [ ! -f /tmp/verify-tarball.tar.gz ]; then
            echo "::error::Failed to download release tarball after 5 attempts"
            exit 1
          fi

          ACTUAL_SHA=$(sha256sum /tmp/verify-tarball.tar.gz | cut -d' ' -f1)
          rm -f /tmp/verify-tarball.tar.gz

          if [ "$ACTUAL_SHA" != "$EXPECTED_SHA" ]; then
            echo "::error::SHA256 MISMATCH! Expected: ${EXPECTED_SHA}, Got: ${ACTUAL_SHA}"
            echo "Aborting AUR push to prevent broken package."
            exit 1
          fi

          echo "Verified: SHA256 matches (${ACTUAL_SHA})"

      - name: Setup SSH for AUR
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AUR_SSH_KEY }}" > ~/.ssh/aur
          chmod 600 ~/.ssh/aur
          ssh-keyscan -t rsa aur.archlinux.org >> ~/.ssh/known_hosts

          # Configure SSH to use the key
          cat << EOF >> ~/.ssh/config
          Host aur.archlinux.org
            User aur
            IdentityFile ~/.ssh/aur
            StrictHostKeyChecking no
          EOF

      - name: Push to AUR
        if: steps.check.outputs.needs_update == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          # Configure git
          git config --global user.name "${{ secrets.AUR_USERNAME }}"
          git config --global user.email "${{ secrets.AUR_EMAIL }}"

          # Clone AUR repository
          git clone ssh://aur@aur.archlinux.org/claude-desktop-bin.git aur-repo

          # Copy updated files
          cp PKGBUILD .SRCINFO aur-repo/

          # Commit and push
          cd aur-repo
          git add PKGBUILD .SRCINFO
          git diff --staged --quiet || {
            git commit -m "Update to ${{ steps.version.outputs.version }}-${{ steps.pkgrel.outputs.pkgrel }}"
            git push origin master
            echo "Successfully pushed to AUR"
          }

      - name: Update README with new version
        if: steps.check.outputs.needs_update == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Update version numbers in README
          sed -i -E "s/claude-desktop_[0-9]+\.[0-9]+\.[0-9]+_amd64\.deb/claude-desktop_${VERSION}_amd64.deb/g" README.md
          sed -i -E "s/Claude_Desktop-[0-9]+\.[0-9]+\.[0-9]+-x86_64\.AppImage/Claude_Desktop-${VERSION}-x86_64.AppImage/g" README.md

          # Commit and push if changed
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          git diff --staged --quiet || {
            git commit -m "Update README install commands to v${VERSION}"
            git push origin master
          }

      - name: Cleanup
        if: always()
        run: |
          rm -f Claude-Setup-x64.exe
          rm -rf ~/.ssh/aur
